/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v3/chats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all chats
         * @description Retrieves a paginated list of chats for the authenticated partner filtered by phone number.
         *     Returns all chats involving the specified phone number with their participants and recent activity.
         *
         *     **Pagination:**
         *     - Use `limit` to control page size (default: 20, max: 100)
         *     - The response includes `next_cursor` for fetching the next page
         *     - When `next_cursor` is `null`, there are no more results to fetch
         *     - Pass the `next_cursor` value as the `cursor` parameter for the next request
         *
         *     **Example pagination flow:**
         *     1. First request: `GET /v3/chats?from=%2B12223334444&limit=20`
         *     2. Response includes `next_cursor: "20"` (more results exist)
         *     3. Next request: `GET /v3/chats?from=%2B12223334444&limit=20&cursor=20`
         *     4. Response includes `next_cursor: null` (no more results)
         */
        get: operations["listChats"];
        put?: never;
        /**
         * Create a new chat
         * @description Create a new chat with specified participants and send an initial message.
         *     The initial message is required when creating a chat.
         *
         *     ## Message Effects
         *
         *     You can add iMessage effects to make your messages more expressive. Effects are
         *     optional and can be either screen effects (full-screen animations) or bubble effects
         *     (message bubble animations).
         *
         *     **Screen Effects:** `confetti`, `fireworks`, `lasers`, `sparkles`, `celebration`,
         *     `hearts`, `love`, `balloons`, `happy_birthday`, `echo`, `spotlight`
         *
         *     **Bubble Effects:** `slam`, `loud`, `gentle`, `invisible`
         *
         *     Only one effect type can be applied per message.
         */
        post: operations["createChat"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/chats/{chatId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a chat by ID
         * @description Retrieve a chat by its unique identifier.
         */
        get: operations["getChat"];
        /**
         * Update a chat
         * @description Update chat properties such as display name and group chat icon.
         */
        put: operations["updateChat"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/chats/{chatId}/participants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add a participant to a chat
         * @description Add a new participant to an existing group chat.
         *
         *     **Requirements:**
         *     - Group chats only (3+ existing participants)
         *     - New participant must support the same messaging service as the group
         *     - Cross-service additions not allowed (e.g., can't add RCS-only user to iMessage group)
         *     - For cross-service scenarios, create a new chat instead
         */
        post: operations["addParticipant"];
        /**
         * Remove a participant from a chat
         * @description Remove a participant from an existing group chat.
         *
         *     **Requirements:**
         *     - Group chats only
         *     - Must have 3+ participants after removal
         */
        delete: operations["removeParticipant"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/chats/{chatId}/typing": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start typing indicator
         * @description Send a typing indicator to show that someone is typing in the chat.
         *
         *     **Note:** Group chat typing indicators are not currently supported.
         */
        post: operations["startTyping"];
        /**
         * Stop typing indicator
         * @description Stop the typing indicator for the chat.
         *
         *     **Note:** Typing indicators are automatically stopped when a message is sent,
         *     so calling this endpoint after sending a message is unnecessary.
         *
         *     **Note:** Group chat typing indicators are not currently supported.
         */
        delete: operations["stopTyping"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/chats/{chatId}/read": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Mark chat as read
         * @description Mark all messages in a chat as read.
         */
        post: operations["markChatAsRead"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/chats/{chatId}/share_contact_card": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Share your contact card with a chat
         * @description Share your contact information (Name and Photo Sharing) with a chat.
         */
        post: operations["shareContactWithChat"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/chats/{chatId}/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get messages from a chat
         * @description Retrieve messages from a specific chat with pagination support.
         */
        get: operations["getMessages"];
        put?: never;
        /**
         * Send a message to an existing chat
         * @description Send a message to an existing chat. Use this endpoint when you already have
         *     a chat ID and want to send additional messages to it.
         *
         *     ## Message Effects
         *
         *     You can add iMessage effects to make your messages more expressive. Effects are
         *     optional and can be either screen effects (full-screen animations) or bubble effects
         *     (message bubble animations).
         *
         *     **Screen Effects:** `confetti`, `fireworks`, `lasers`, `sparkles`, `celebration`,
         *     `hearts`, `love`, `balloons`, `happy_birthday`, `echo`, `spotlight`
         *
         *     **Bubble Effects:** `slam`, `loud`, `gentle`, `invisible`
         *
         *     Only one effect type can be applied per message.
         */
        post: operations["sendMessageToChat"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/messages/{messageId}/thread": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all messages in a thread
         * @description Retrieve all messages in a conversation thread. Given any message ID in the thread,
         *     returns the originator message and all replies in chronological order.
         *
         *     If the message is not part of a thread, returns just that single message.
         *
         *     Supports pagination and configurable ordering.
         */
        get: operations["getMessageThread"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/chats/{chatId}/voicememo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Send a voice memo to a chat
         * @description Send a voice memo to all participants in a chat. Voice memos MUST be sent alone without text
         *     or other attachments.
         *
         *     **Supported audio formats:**
         *     - MP3 (audio/mpeg)
         *     - M4A (audio/x-m4a, audio/mp4)
         *     - AAC (audio/aac)
         *     - CAF (audio/x-caf) - Core Audio Format
         *     - WAV (audio/wav)
         *     - AIFF (audio/aiff, audio/x-aiff)
         *     - AMR (audio/amr)
         */
        post: operations["sendVoiceMemoToChat"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/messages/{messageId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a message by ID
         * @description Retrieve a specific message by its ID. This endpoint returns the full message
         *     details including text, attachments, reactions, and metadata.
         */
        get: operations["getMessage"];
        put?: never;
        post?: never;
        /**
         * Delete a message from system
         * @description Deletes a message from the Linq API only. This does NOT unsend or remove the message
         *     from the actual chat - recipients will still see the message.
         *
         *     Use this endpoint to remove messages from your records and prevent them from appearing
         *     in API responses.
         */
        delete: operations["deleteMessage"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/messages/{messageId}/reactions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add or remove a reaction to a message
         * @description Add or remove emoji reactions to messages. Reactions let users express
         *     their response to a message without sending a new message.
         *
         *     **Supported Reactions:**
         *     - love ‚ù§Ô∏è
         *     - like üëç
         *     - dislike üëé
         *     - laugh üòÇ
         *     - emphasize ‚ÄºÔ∏è
         *     - question ‚ùì
         *     - custom - any emoji (use `custom_emoji` field to specify)
         */
        post: operations["sendReaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Pre-upload a file
         * @description **This endpoint is optional.** You can send media by simply providing a URL in your
         *     message's media part ‚Äî no pre-upload required. Use this endpoint only when you want
         *     to upload a file ahead of time for reuse or latency optimization.
         *
         *     Returns a presigned upload URL and a permanent `attachment_id` you can reference
         *     in future messages.
         *
         *     ## Step 1: Request an upload URL
         *
         *     Call this endpoint with file metadata:
         *
         *     ```json
         *     POST /v3/attachments
         *     {
         *       "filename": "photo.jpg",
         *       "content_type": "image/jpeg",
         *       "size_bytes": 1024000
         *     }
         *     ```
         *
         *     The response includes an `upload_url` (valid for 15 minutes) and a permanent `attachment_id`.
         *
         *     ## Step 2: Upload the file
         *
         *     Make a PUT request to the `upload_url` with the raw file bytes as the request body.. Include the headers from `required_headers`.
         *     The request body is the binary file content ‚Äî **not** JSON, **not** multipart form data.
         *
         *     ```bash
         *     curl -X PUT "<upload_url from step 1>" \
         *       -H "Content-Type: image/jpeg" \
         *       --data-binary @filebytes
         *     ```
         *
         *     ## Step 3: Send a message with the attachment
         *
         *     Reference the `attachment_id` in a media part. The ID never expires ‚Äî use it in as many messages as you want.
         *
         *     ```json
         *     POST /v3/messages
         *     {
         *       "to": ["+15551234567"],
         *       "from": "+15559876543",
         *       "parts": [
         *         { "type": "media", "attachment_id": "<attachment_id from step 1>" }
         *       ]
         *     }
         *     ```
         *
         *     ## When to use this instead of a URL in the media part
         *
         *     - Sending the same file to multiple recipients (avoids re-downloading each time)
         *     - Large files where you want to separate upload from message send
         *     - Latency-sensitive sends where the file should already be stored
         *
         *     If you just need to send a file once, skip all of this and pass a `url` directly in the media part instead.
         *
         *     **File Size Limit:** 100MB
         *
         *     **Unsupported Types:** WebP, SVG, FLAC, OGG, and executable files are explicitly rejected.
         */
        post: operations["requestUpload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/attachments/{attachmentId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachment metadata
         * @description Retrieve metadata for a specific attachment including its status,
         *     file information, and URLs for downloading.
         */
        get: operations["getAttachment"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/phonenumbers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List phone numbers
         * @description Returns all phone numbers assigned to the authenticated partner.
         *     Use this endpoint to discover which phone numbers are available for
         *     sending messages via the `from` field in create chat and send message requests.
         */
        get: operations["listPhoneNumbers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/webhook-events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List available webhook event types
         * @description Returns all available webhook event types that can be subscribed to.
         *     Use this endpoint to discover valid values for the `subscribed_events`
         *     field when creating or updating webhook subscriptions.
         */
        get: operations["listWebhookEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/webhook-subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all webhook subscriptions
         * @description Retrieve all webhook subscriptions for the authenticated partner.
         *     Returns a list of active and inactive subscriptions with their
         *     configuration and status.
         */
        get: operations["listWebhookSubscriptions"];
        put?: never;
        /**
         * Create a new webhook subscription
         * @description Create a new webhook subscription to receive events at a target URL.
         *     Upon creation, a signing secret is generated for verifying webhook
         *     authenticity. **Store this secret securely ‚Äî it cannot be retrieved later.**
         *
         *     **Webhook Delivery:**
         *     - Events are sent via HTTP POST to the target URL
         *     - Each request includes `X-Webhook-Signature` and `X-Webhook-Timestamp` headers
         *     - Signature is HMAC-SHA256 over `{timestamp}.{payload}` ‚Äî see [Webhook Events](/docs/webhook-events) for verification details
         *     - Failed deliveries (5xx, 429, network errors) are retried up to 6 times with exponential backoff: 2s, 4s, 8s, 16s, 30s
         *     - Client errors (4xx except 429) are not retried
         */
        post: operations["createWebhookSubscription"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/webhook-subscriptions/{subscriptionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a webhook subscription by ID
         * @description Retrieve details for a specific webhook subscription including its
         *     target URL, subscribed events, and current status.
         */
        get: operations["getWebhookSubscription"];
        /**
         * Update a webhook subscription
         * @description Update an existing webhook subscription. You can modify the target URL,
         *     subscribed events, or activate/deactivate the subscription.
         *
         *     **Note:** The signing secret cannot be changed via this endpoint.
         */
        put: operations["updateWebhookSubscription"];
        post?: never;
        /**
         * Delete a webhook subscription
         * @description Delete a webhook subscription.
         */
        delete: operations["deleteWebhookSubscription"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export interface webhooks {
    "message.sent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Message sent
         * @description Triggered when a message has been successfully sent from your phone number.
         *     This confirms the message has been sent, but potentially has not yet been delivered.
         *
         *     **Timestamps:** `sent_at` is set, `delivered_at` and `read_at` are null.
         */
        post: operations["webhookMessageSentV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "message.received": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Message received
         * @description Triggered when an incoming message is received on your phone number.
         *     Contains the full message content including any attachments.
         *
         *     **Timestamps:** `sent_at` is set, `delivered_at` and `read_at` are null.
         */
        post: operations["webhookMessageReceivedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "message.read": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Message read
         * @description Triggered when a sent message has been read by the recipient.
         *     Only available for iMessage conversations with read receipts enabled.
         *
         *     **Timestamps:** `sent_at`, `delivered_at`, and `read_at` are all set.
         */
        post: operations["webhookMessageReadV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "message.delivered": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Message delivered
         * @description Triggered when a sent message has been delivered to the recipient's device.
         *     This confirms the message reached the recipient, but does not indicate it was read.
         *     Only available for iMessage conversations with delivery receipts.
         *
         *     **Timestamps:** `sent_at` and `delivered_at` are set, `read_at` is null.
         */
        post: operations["webhookMessageDeliveredV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "message.failed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Message delivery failed
         * @description Triggered when a message fails to be delivered. This can happen due to:
         *     - Request timeout (message expired before being processed)
         *     - Upstream service error (processing failed after retries)
         *     - Request cancelled (message was explicitly cancelled)
         *     - Service unavailable (no service available to process the request)
         *
         *     Note: The original message content may not be available if the message
         *     expired before being consumed by a processor.
         */
        post: operations["webhookMessageFailedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "reaction.added": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reaction added
         * @description Triggered when a reaction (tapback) is added to a message.
         *     Includes standard reactions like "loved", "liked", "disliked", etc.
         *     and custom emoji reactions.
         */
        post: operations["webhookReactionAddedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "reaction.removed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reaction removed
         * @description Triggered when a reaction (tapback) is removed from a message.
         */
        post: operations["webhookReactionRemovedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "participant.added": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Participant added
         * @description Triggered when a new participant is added to a group chat.
         */
        post: operations["webhookParticipantAddedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "participant.removed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Participant removed
         * @description Triggered when a participant is removed from a group chat.
         */
        post: operations["webhookParticipantRemovedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "chat.group_name_updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Group name updated
         * @description Triggered when a group chat's display name is updated.
         *     A null `new_value` indicates the name was removed.
         */
        post: operations["webhookChatGroupNameUpdatedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "chat.group_icon_updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Group icon updated
         * @description Triggered when a group chat's icon is updated.
         *     A null `new_value` indicates the icon was removed.
         */
        post: operations["webhookChatGroupIconUpdatedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "chat.group_name_update_failed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Group name update failed
         * @description Triggered when a group chat name update request fails.
         */
        post: operations["webhookChatGroupNameUpdateFailedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "chat.group_icon_update_failed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Group icon update failed
         * @description Triggered when a group chat icon update request fails.
         */
        post: operations["webhookChatGroupIconUpdateFailedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "chat.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Chat created
         * @description Triggered when a new chat is created.
         */
        post: operations["webhookChatCreatedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "chat.typing_indicator.started": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Typing indicator started
         * @description Triggered when a participant starts typing in a chat.
         */
        post: operations["webhookChatTypingIndicatorStartedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "chat.typing_indicator.stopped": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Typing indicator stopped
         * @description Triggered when a participant stops typing in a chat.
         */
        post: operations["webhookChatTypingIndicatorStoppedV2026"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export interface components {
    schemas: {
        /**
         * @description Current delivery status of a message
         * @example pending
         * @enum {string}
         */
        DeliveryStatus: "pending" | "queued" | "sent" | "delivered" | "failed";
        /** @description A message that was sent (used in CreateChat and SendMessage responses) */
        SentMessage: {
            /**
             * Format: uuid
             * @description Message identifier (UUID)
             * @example 69a37c7d-af4f-4b5e-af42-e28e98ce873a
             */
            id: string;
            /**
             * @description Service used to send this message
             * @example iMessage
             * @enum {string|null}
             */
            service?: "iMessage" | "SMS" | "RCS" | null;
            /**
             * @description Preferred service for sending this message
             * @example iMessage
             * @enum {string|null}
             */
            preferred_service?: "iMessage" | "SMS" | "RCS" | null;
            /** @description Message parts in order (text and media) */
            parts: (components["schemas"]["TextPartResponse"] | components["schemas"]["MediaPartResponse"])[];
            /**
             * Format: date-time
             * @description When the message was sent
             * @example 2025-10-23T13:07:55.019-05:00
             */
            sent_at: string;
            /**
             * Format: date-time
             * @description When the message was delivered
             * @example null
             */
            delivered_at?: string | null;
            delivery_status: components["schemas"]["DeliveryStatus"];
            /**
             * @description Whether the message has been read
             * @example false
             */
            is_read: boolean;
            /** @description iMessage effect applied to this message (screen or bubble effect) */
            effect?: components["schemas"]["MessageEffect"] | null;
            /** @description The sender of this message as a full handle object */
            from_handle?: components["schemas"]["ChatHandle"] | null;
            reply_to?: components["schemas"]["ReplyTo"] | null;
        };
        /** @description Response for sending a message to a chat */
        SendMessageResponse: {
            /**
             * Format: uuid
             * @description Unique identifier of the chat this message was sent to
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id: string;
            message: components["schemas"]["SentMessage"];
        };
        /** @description Response containing messages in a thread with pagination */
        GetThreadResponse: {
            /** @description Messages in the thread, ordered by the specified order parameter */
            messages: components["schemas"]["Message"][];
            /**
             * @description Cursor for fetching the next page of results (null if no more results)
             * @example eyJpZCI6IjEyMzQ1Njc4OTAiLCJ0cyI6MTYzMDUwMDAwMH0=
             */
            next_cursor?: string | null;
        };
        /** @description Request to send a voice memo to a chat (chat_id provided in path) */
        SendVoiceMemoToChatRequest: {
            /**
             * @description Sender phone number in E.164 format
             * @example +12052535597
             */
            from: string;
            /**
             * Format: uri
             * @description URL of the voice memo audio file. Must be a publicly accessible HTTPS URL.
             * @example https://example.com/voice-memo.m4a
             */
            voice_memo_url: string;
        };
        SendVoiceMemoResponse: {
            /**
             * @description Whether the voice memo was successfully queued
             * @example true
             */
            success: boolean;
            message: components["schemas"]["VoiceMemoMessage"];
            chat: components["schemas"]["ChatInfo"];
        };
        /** @description Response for sending a voice memo to a chat */
        SendVoiceMemoToChatResult: {
            voice_memo: {
                /**
                 * Format: uuid
                 * @description Message identifier
                 * @example 69a37c7d-af4f-4b5e-af42-e28e98ce873a
                 */
                id: string;
                /**
                 * @description Sender phone number
                 * @example +12052535597
                 */
                from: string;
                /**
                 * @description Recipient handles (phone numbers or email addresses)
                 * @example [
                 *       "+12052532136"
                 *     ]
                 */
                to: string[];
                /**
                 * @description Current delivery status
                 * @example queued
                 */
                status: string;
                /**
                 * @description Service used to send this voice memo
                 * @example iMessage
                 * @enum {string|null}
                 */
                service?: "iMessage" | "SMS" | "RCS" | null;
                voice_memo: components["schemas"]["VoiceMemoAttachment"];
                /**
                 * Format: date-time
                 * @description When the voice memo was created
                 */
                created_at: string;
                chat: components["schemas"]["ChatInfo"];
            };
        };
        VoiceMemoMessage: {
            /**
             * Format: uuid
             * @description Message identifier
             * @example 69a37c7d-af4f-4b5e-af42-e28e98ce873a
             */
            id: string;
            /**
             * Format: uuid
             * @description Chat identifier
             * @example 94c6bf33-31d9-40e3-a0e9-f94250ecedb9
             */
            chat_id: string;
            /**
             * @deprecated
             * @description DEPRECATED: Use from_handle instead. Sender phone number.
             * @example +12052535597
             */
            from: string;
            /** @description The sender of this voice memo as a full handle object */
            from_handle?: components["schemas"]["ChatHandle"];
            /**
             * @description Recipient handles (phone numbers or email addresses)
             * @example [
             *       "+12052532136"
             *     ]
             */
            to: string[];
            voice_memo: components["schemas"]["VoiceMemoAttachment"];
            /**
             * @description Current delivery status
             * @example queued
             */
            status: string;
            /**
             * Format: date-time
             * @description When the voice memo was created
             */
            created_at: string;
        };
        VoiceMemoAttachment: {
            /**
             * Format: uuid
             * @description Attachment identifier
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            id: string;
            /**
             * Format: uri
             * @description CDN URL for downloading the voice memo
             * @example https://cdn.example.com/voice-memos/abc123.m4a
             */
            url: string;
            /**
             * @description Original filename
             * @example voice-memo.m4a
             */
            filename: string;
            /**
             * @description Audio MIME type
             * @example audio/x-m4a
             */
            mime_type: string;
            /**
             * @description File size in bytes
             * @example 524288
             */
            size_bytes: number;
            /**
             * @description Duration in milliseconds
             * @example 15000
             */
            duration_ms?: number | null;
        };
        ChatInfo: {
            /**
             * Format: uuid
             * @description Chat identifier
             */
            id: string;
            /** @description Chat participants */
            handles: components["schemas"]["ChatHandle"][];
            /** @description Whether this is a group chat */
            is_group: boolean;
            /**
             * @description Messaging service
             * @example iMessage
             */
            service: string;
            /** @description Whether the chat is active */
            is_active: boolean;
        };
        MessagePart: components["schemas"]["TextPart"] | components["schemas"]["MediaPart"];
        /**
         * @example {
         *       "type": "text",
         *       "value": "Check this out!"
         *     }
         */
        TextPart: {
            /**
             * @description Indicates this is a text message part (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "text";
            /**
             * @description The text content
             * @example Hello!
             */
            value: string;
            /**
             * @description Optional idempotency key for this specific message part.
             *     Use this to prevent duplicate sends of the same part.
             * @example text-part-abc123
             */
            idempotency_key?: string;
        };
        /**
         * @example {
         *       "type": "media",
         *       "url": "https://skywalker-next.linqapp.com/_next/static/media/conversations-imessage.0dc825b0.png"
         *     }
         */
        MediaPart: {
            /**
             * @description Indicates this is a media attachment part (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "media";
            /**
             * Format: uri
             * @description Any publicly accessible HTTPS URL to the media file. The server downloads and
             *     sends the file automatically ‚Äî no pre-upload step required.
             *
             *     **Size limit:** 10MB maximum for URL-based downloads. For larger files (up to 100MB),
             *     use the pre-upload flow: `POST /v3/attachments` to get a presigned URL, upload directly,
             *     then reference by `attachment_id`.
             *
             *     **Requirements:**
             *     - URL must include a supported file extension (e.g., `.jpg`, `.pdf`)
             *     - Server's Content-Type header must match the URL extension
             *
             *     **Supported formats:**
             *     - Images: .jpg, .jpeg, .png, .gif, .heic, .heif, .tif, .tiff, .bmp
             *     - Videos: .mp4, .mov, .m4v, .mpeg, .mpg, .3gp
             *     - Documents: .pdf, .txt, .rtf, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pages, .numbers, .key, .epub, .zip, .html, .htm
             *     - Contact & Calendar: .vcf, .ics
             *
             *     **Note:** Audio files should use the dedicated `/v3/chats/{chatId}/voicememo` endpoint.
             *     For repeated sends of the same file, use `attachment_id` to avoid redundant downloads.
             *
             *     Either `url` or `attachment_id` must be provided, but not both.
             * @example https://example.com/images/photo.jpg
             */
            url?: string;
            /**
             * Format: uuid
             * @description Reference to a file pre-uploaded via `POST /v3/attachments` (optional).
             *     The file is already stored, so sends using this ID skip the download step ‚Äî
             *     useful when sending the same file to many recipients.
             *
             *     Either `url` or `attachment_id` must be provided, but not both.
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            attachment_id?: string;
            /**
             * @description Optional idempotency key for this specific message part.
             *     Use this to prevent duplicate sends of the same part.
             * @example media-part-xyz789
             */
            idempotency_key?: string;
        };
        /**
         * @description A text message part
         * @example {
         *       "type": "text",
         *       "value": "Hello!"
         *     }
         */
        TextPartResponse: {
            /**
             * @description Indicates this is a text message part
             * @enum {string}
             */
            type: "text";
            /**
             * @description The text content
             * @example Check this out!
             */
            value: string;
            /** @description Reactions on this message part */
            reactions: components["schemas"]["Reaction"][] | null;
        };
        /**
         * @description A media attachment part
         * @example {
         *       "type": "media",
         *       "id": "abc12345-1234-5678-9abc-def012345678",
         *       "url": "https://cdn.linqapp.com/attachments/abc12345/photo.jpg?signature=...",
         *       "filename": "photo.jpg",
         *       "mime_type": "image/jpeg",
         *       "size_bytes": 245678
         *     }
         */
        MediaPartResponse: {
            /**
             * @description Indicates this is a media attachment part
             * @enum {string}
             */
            type: "media";
            /**
             * Format: uuid
             * @description Unique attachment identifier
             * @example abc12345-1234-5678-9abc-def012345678
             */
            id: string;
            /**
             * Format: uri
             * @description Presigned URL for downloading the attachment (expires in 1 hour).
             * @example https://cdn.linqapp.com/attachments/550e8400/photo.jpg?signature=...
             */
            url: string;
            /**
             * @description Original filename
             * @example photo.jpg
             */
            filename: string;
            /**
             * @description MIME type of the file
             * @example image/jpeg
             */
            mime_type: string;
            /**
             * @description File size in bytes
             * @example 245678
             */
            size_bytes: number;
            /** @description Reactions on this message part */
            reactions: components["schemas"]["Reaction"][] | null;
        };
        /**
         * @description Message effects for iMessage. Only one effect type can be applied per message.
         *     Screen effects play a full-screen animation. Bubble effects animate the message bubble.
         */
        MessageEffects: {
            /**
             * @description Full-screen animation effect. Available screen effects:
             *     - confetti: Colorful confetti falls from top of screen
             *     - fireworks: Fireworks explode across the screen
             *     - lasers: Laser beams scan across the screen
             *     - sparkles: Sparkle/celebration effect
             *     - celebration: Alias for sparkles (matches UI name)
             *     - hearts: Floating hearts fill the screen
             *     - love: Alias for hearts (matches UI name)
             *     - balloons: Colorful balloons float up
             *     - happy_birthday: Alias for balloons
             *     - echo: Message text echoes/multiplies across screen
             *     - spotlight: Spotlight illuminates the message
             * @example confetti
             * @enum {string}
             */
            screen_effect?: "confetti" | "fireworks" | "lasers" | "sparkles" | "celebration" | "hearts" | "love" | "balloons" | "happy_birthday" | "echo" | "spotlight";
            /**
             * @description Message bubble animation effect. Available bubble effects:
             *     - slam: Message slams onto screen with impact
             *     - loud: Message appears larger with emphasis
             *     - gentle: Message fades in softly
             *     - invisible: Invisible ink effect (revealed on tap)
             * @example slam
             * @enum {string}
             */
            bubble_effect?: "slam" | "loud" | "gentle" | "invisible";
        };
        /**
         * @description Message content container. Groups all message-related fields together,
         *     separating the "what" (message content) from the "where" (routing fields like from/to).
         */
        MessageContent: {
            /**
             * @description Array of message parts. Each part can be either text or media.
             *     Parts are displayed in order. Text and media can be mixed.
             *
             *     **Supported Media:**
             *     - Images: .jpg, .jpeg, .png, .gif, .heic, .heif, .tif, .tiff, .bmp
             *     - Videos: .mp4, .mov, .m4v, .mpeg, .mpg, .3gp
             *     - Documents: .pdf, .txt, .rtf, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pages, .numbers, .key, .epub, .zip, .html, .htm
             *     - Contact & Calendar: .vcf, .ics
             *
             *     **Audio Handling:**
             *     - Audio files (voice memos) should use the dedicated `/v3/chats/{chatId}/voicememo` endpoint
             *     - This ensures proper voice memo formatting and playback in iMessage
             *
             *     **Validation Rule:** Consecutive text parts are not allowed. Text parts must
             *     be separated by media parts. For example, [text, text] is invalid, but
             *     [text, media, text] is valid.
             * @example [
             *       {
             *         "type": "text",
             *         "value": "Check this out!"
             *       },
             *       {
             *         "type": "media",
             *         "url": "https://skywalker-next.linqapp.com/_next/static/media/conversations-imessage.0dc825b0.png"
             *       }
             *     ]
             */
            parts: components["schemas"]["MessagePart"][];
            /** @description iMessage effect to apply to this message (screen or bubble effect) */
            effect?: components["schemas"]["MessageEffect"];
            /** @description Reply to another message to create a threaded conversation */
            reply_to?: components["schemas"]["ReplyTo"];
            /**
             * @description Optional idempotency key for this message.
             *     Use this to prevent duplicate sends of the same message.
             * @example msg-abc123xyz
             */
            idempotency_key?: string;
            /**
             * @description Preferred messaging service to use for this message.
             *     If not specified, uses default fallback chain: iMessage ‚Üí RCS ‚Üí SMS.
             *     - iMessage: Enforces iMessage without fallback to RCS or SMS. Message fails if recipient doesn't support iMessage.
             *     - RCS: Enforces RCS or SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
             *     - SMS: Enforces SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
             * @example iMessage
             * @enum {string}
             */
            preferred_service?: "iMessage" | "RCS" | "SMS";
        };
        ErrorResponse: {
            error: components["schemas"]["ErrorDetail"];
            /**
             * @description Always false for error responses
             * @example false
             */
            success: boolean;
            /**
             * @description Unique trace ID for request tracing and debugging
             * @example trace_abc123def456
             */
            trace_id?: string;
        };
        ErrorDetail: {
            /**
             * @description HTTP status code (e.g., 400, 404, 500)
             * @example 400
             */
            status: number;
            code: components["schemas"]["ErrorCode"];
            /**
             * @description Human-readable error message
             * @example Phone number must be in E.164 format
             */
            message: string;
        };
        Message: {
            /**
             * Format: uuid
             * @description Unique identifier for the message
             * @example 69a37c7d-af4f-4b5e-af42-e28e98ce873a
             */
            id: string;
            /**
             * Format: uuid
             * @description ID of the chat this message belongs to
             * @example 94c6bf33-31d9-40e3-a0e9-f94250ecedb9
             */
            chat_id: string;
            /**
             * @description Service used to send/receive this message
             * @example iMessage
             * @enum {string|null}
             */
            service?: "iMessage" | "SMS" | "RCS" | null;
            /**
             * @description Preferred service for sending this message
             * @example iMessage
             * @enum {string|null}
             */
            preferred_service?: "iMessage" | "SMS" | "RCS" | null;
            /**
             * @deprecated
             * @description DEPRECATED: Use from_handle instead. Phone number of the message sender.
             * @example +12052535597
             */
            from?: string | null;
            /** @description The sender of this message as a full handle object */
            from_handle?: components["schemas"]["ChatHandle"] | null;
            /** @description Message parts in order (text and media) */
            parts?: (components["schemas"]["TextPartResponse"] | components["schemas"]["MediaPartResponse"])[] | null;
            reply_to?: components["schemas"]["ReplyTo"] | null;
            /**
             * @description Whether this message was sent by the authenticated user
             * @example true
             */
            is_from_me: boolean;
            /**
             * @description Whether the message has been delivered
             * @example true
             */
            is_delivered: boolean;
            /**
             * @description Whether the message has been read
             * @example false
             */
            is_read: boolean;
            /**
             * Format: date-time
             * @description When the message was created
             * @example 2024-01-15T10:30:00Z
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the message was last updated
             * @example 2024-01-15T10:30:00Z
             */
            updated_at: string;
            /**
             * Format: date-time
             * @description When the message was sent
             * @example 2024-01-15T10:30:05Z
             */
            sent_at?: string | null;
            /**
             * Format: date-time
             * @description When the message was delivered
             * @example 2024-01-15T10:30:10Z
             */
            delivered_at?: string | null;
            /**
             * Format: date-time
             * @description When the message was read
             * @example 2024-01-15T10:35:00Z
             */
            read_at?: string | null;
            /** @description iMessage effect applied to this message (screen or bubble effect) */
            effect?: components["schemas"]["MessageEffect"] | null;
        };
        /** @description iMessage effect applied to a message (screen or bubble effect) */
        MessageEffect: {
            /**
             * @description Type of effect
             * @example screen
             * @enum {string}
             */
            type?: "screen" | "bubble";
            /**
             * @description Name of the effect. Common values:
             *     - Screen effects: confetti, fireworks, lasers, sparkles, celebration, hearts, love, balloons, happy_birthday, echo, spotlight
             *     - Bubble effects: slam, loud, gentle, invisible
             * @example confetti
             */
            name?: string;
        };
        /** @description Indicates this message is a threaded reply to another message */
        ReplyTo: {
            /**
             * Format: uuid
             * @description The ID of the message to reply to
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            message_id: string;
            /**
             * Format: int32
             * @description The specific message part to reply to (0-based index).
             *     Defaults to 0 (first part) if not provided.
             *     Use this when replying to a specific part of a multipart message.
             * @example 0
             */
            part_index?: number;
        };
        Attachment: {
            /**
             * @description Unique identifier for the attachment (UUID)
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            id: string;
            /**
             * @description Original filename of the attachment
             * @example photo.jpg
             */
            filename: string;
            content_type: components["schemas"]["SupportedContentType"];
            /**
             * Format: int64
             * @description Size of the attachment in bytes
             * @example 1024000
             */
            size_bytes: number;
            /**
             * @description Current upload/processing status
             * @example complete
             * @enum {string}
             */
            status: "pending" | "complete" | "failed";
            /**
             * Format: uri
             * @description URL to download the attachment
             */
            download_url?: string;
            /**
             * Format: date-time
             * @description When the attachment was created
             * @example 2024-01-15T10:30:00Z
             */
            created_at: string;
        };
        /**
         * @description Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
         *     Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
         * @example love
         * @enum {string}
         */
        ReactionType: "love" | "like" | "dislike" | "laugh" | "emphasize" | "question" | "custom";
        Reaction: {
            /**
             * @description Whether this reaction is from the current user
             * @example false
             */
            is_me: boolean;
            handle: components["schemas"]["ChatHandle"];
            type: components["schemas"]["ReactionType"];
            /**
             * @description Custom emoji if type is "custom", null otherwise
             * @example üöÄ
             */
            custom_emoji?: string | null;
        };
        DeleteMessageRequest: {
            /**
             * Format: uuid
             * @description ID of the chat containing the message to delete
             * @example 94c6bf33-31d9-40e3-a0e9-f94250ecedb9
             */
            chat_id: string;
        };
        SendReactionRequest: {
            /**
             * @description Whether to add or remove the reaction
             * @example add
             * @enum {string}
             */
            operation: "add" | "remove";
            type: components["schemas"]["ReactionType"];
            /**
             * @description Custom emoji string. Required when type is "custom".
             * @example üòç
             */
            custom_emoji?: string;
            /**
             * @description Optional index of the message part to react to.
             *     If not provided, reacts to the entire message (part 0).
             * @example 1
             */
            part_index?: number;
        };
        /**
         * @description Supported MIME types for file attachments and media URLs.
         *
         *     **Images:** image/jpeg, image/png, image/gif, image/heic, image/heif, image/tiff, image/bmp
         *
         *     **Videos:** video/mp4, video/quicktime, video/mpeg, video/3gpp
         *
         *     **Audio:** audio/mpeg, audio/mp4, audio/x-m4a, audio/x-caf, audio/wav, audio/aiff, audio/aac, audio/amr
         *
         *     **Documents:** application/pdf, text/plain, text/vcard, text/rtf, text/csv, text/html, text/calendar, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.apple.pages, application/vnd.apple.numbers, application/vnd.apple.keynote, application/epub+zip, application/zip
         *
         *     **Unsupported:** WebP, SVG, FLAC, OGG, and executable files are explicitly rejected.
         * @example image/jpeg
         * @enum {string}
         */
        SupportedContentType: "image/jpeg" | "image/jpg" | "image/png" | "image/gif" | "image/heic" | "image/heif" | "image/tiff" | "image/bmp" | "image/x-ms-bmp" | "video/mp4" | "video/quicktime" | "video/mpeg" | "video/x-m4v" | "video/3gpp" | "audio/mpeg" | "audio/mp3" | "audio/mp4" | "audio/x-m4a" | "audio/m4a" | "audio/x-caf" | "audio/wav" | "audio/x-wav" | "audio/aiff" | "audio/x-aiff" | "audio/aac" | "audio/x-aac" | "audio/amr" | "application/pdf" | "text/plain" | "text/vcard" | "text/x-vcard" | "text/rtf" | "application/rtf" | "text/csv" | "text/html" | "text/calendar" | "application/msword" | "application/vnd.openxmlformats-officedocument.wordprocessingml.document" | "application/vnd.ms-excel" | "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" | "application/vnd.ms-powerpoint" | "application/vnd.openxmlformats-officedocument.presentationml.presentation" | "application/vnd.apple.pages" | "application/x-iwork-pages-sffpages" | "application/vnd.apple.numbers" | "application/x-iwork-numbers-sffnumbers" | "application/vnd.apple.keynote" | "application/x-iwork-keynote-sffkey" | "application/epub+zip" | "application/zip" | "application/x-zip-compressed";
        RequestUploadRequest: {
            /**
             * @description Name of the file to upload
             * @example photo.jpg
             */
            filename: string;
            content_type: components["schemas"]["SupportedContentType"];
            /**
             * Format: int64
             * @description Size of the file in bytes (max 100MB)
             * @example 1024000
             */
            size_bytes: number;
        };
        RequestUploadResult: {
            /**
             * Format: uuid
             * @description Unique identifier for the attachment (for status checks via GET /v3/attachments/{id})
             * @example abc12345-1234-5678-9abc-def012345678
             */
            attachment_id: string;
            /**
             * Format: uri
             * @description Presigned URL for uploading the file. PUT the raw binary file content to this URL
             *     with the `required_headers`. Do not JSON-encode or multipart-wrap the body.
             *     Expires after 15 minutes.
             * @example https://uploads.linqapp.com/attachments/abc12345?X-Amz-Algorithm=...
             */
            upload_url: string;
            /**
             * Format: uri
             * @description Permanent CDN URL for the file. Does not expire. Use the `attachment_id`
             *     to reference this file in media parts when sending messages.
             * @example https://cdn.linqapp.com/uploads/partner-id/abc12345/photo.jpg
             */
            download_url: string;
            /**
             * @description HTTP method to use for upload (always PUT)
             * @example PUT
             * @enum {string}
             */
            http_method: "PUT";
            /**
             * Format: date-time
             * @description When the upload URL expires (15 minutes from now)
             * @example 2024-01-15T10:45:00Z
             */
            expires_at: string;
            /**
             * @description HTTP headers required for the upload request
             * @example {
             *       "Content-Type": "image/jpeg"
             *     }
             */
            required_headers: {
                [key: string]: string;
            };
        };
        Chat: {
            /**
             * Format: uuid
             * @description Unique identifier for the chat
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            id: string;
            /**
             * @description Display name for the chat. Defaults to a comma-separated list of recipient handles. Can be updated for group chats.
             * @example +14155551234, +14155559876
             */
            display_name: string | null;
            /**
             * @description Service type for the chat
             * @example iMessage
             * @enum {string|null}
             */
            service?: "iMessage" | "SMS" | "RCS" | null;
            /**
             * @description List of chat participants with full handle details. Always contains at least two handles (your phone number and the other participant).
             * @example [
             *       {
             *         "id": "550e8400-e29b-41d4-a716-446655440010",
             *         "handle": "+14155551234",
             *         "service": "iMessage",
             *         "status": "active",
             *         "joined_at": "2025-05-21T15:30:00.000Z",
             *         "is_me": true
             *       },
             *       {
             *         "id": "550e8400-e29b-41d4-a716-446655440011",
             *         "handle": "+14155559876",
             *         "service": "iMessage",
             *         "status": "active",
             *         "joined_at": "2025-05-21T15:30:00.000Z",
             *         "is_me": false
             *       }
             *     ]
             */
            handles: components["schemas"]["ChatHandle"][];
            /**
             * @description Whether the chat is archived
             * @default false
             */
            is_archived: boolean;
            /**
             * @description Whether this is a group chat
             * @default false
             */
            is_group: boolean;
            /**
             * Format: date-time
             * @description When the chat was created
             * @example 2024-01-15T10:30:00Z
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the chat was last updated
             * @example 2024-01-15T10:30:00Z
             */
            updated_at: string;
        };
        ChatHandle: {
            /**
             * Format: uuid
             * @description Unique identifier for this handle
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            id: string;
            /**
             * @description Phone number (E.164) or email address of the participant
             * @example +15551234567
             */
            handle: string;
            /**
             * @description Service type (iMessage, SMS, RCS, etc.)
             * @example iMessage
             * @enum {string}
             */
            service: "iMessage" | "SMS" | "RCS";
            /**
             * @description Participant status
             * @default active
             * @enum {string|null}
             */
            status: "active" | "left" | "removed" | null;
            /**
             * Format: date-time
             * @description When this participant joined the chat
             * @example 2025-05-21T15:30:00.000-05:00
             */
            joined_at: string;
            /**
             * Format: date-time
             * @description When they left (if applicable)
             */
            left_at?: string | null;
            /**
             * @description Whether this handle belongs to the sender (your phone number)
             * @example false
             */
            is_me?: boolean | null;
        };
        ListChatsResult: {
            /** @description List of chats */
            chats: components["schemas"]["Chat"][];
            /**
             * @description Cursor for fetching the next page of results.
             *     Null if there are no more results to fetch.
             *     Pass this value as the `cursor` parameter in the next request.
             */
            next_cursor?: string | null;
        };
        CreateChatRequest: {
            /**
             * @description Sender phone number in E.164 format. Must be a phone number that the
             *     authenticated partner has permission to send from.
             * @example +12052535597
             */
            from: string;
            /**
             * @description Array of recipient handles (phone numbers in E.164 format or email addresses).
             *     For individual chats, provide one recipient. For group chats, provide multiple.
             * @example [
             *       "+14155559876",
             *       "+14155550123"
             *     ]
             */
            to: string[];
            message: components["schemas"]["MessageContent"];
        };
        /** @description Response for creating a new chat with an initial message */
        CreateChatResult: {
            chat: {
                /**
                 * Format: uuid
                 * @description Unique identifier for the created chat (UUID)
                 * @example 94c6bf33-31d9-40e3-a0e9-f94250ecedb9
                 */
                id: string;
                /**
                 * @description Display name for the chat. Defaults to a comma-separated list of recipient handles. Can be updated for group chats.
                 * @example +14155551234, +14155559876
                 */
                display_name: string | null;
                /**
                 * @description Messaging service used
                 * @example iMessage
                 */
                service: string;
                /**
                 * @description Whether this is a group chat
                 * @example false
                 */
                is_group: boolean;
                /**
                 * @description List of participants in the chat. Always contains at least two handles (your phone number and the other participant).
                 * @example [
                 *       {
                 *         "id": "550e8400-e29b-41d4-a716-446655440010",
                 *         "handle": "+14155551234",
                 *         "service": "iMessage",
                 *         "status": "active",
                 *         "joined_at": "2025-05-21T15:30:00.000Z",
                 *         "is_me": true
                 *       },
                 *       {
                 *         "id": "550e8400-e29b-41d4-a716-446655440011",
                 *         "handle": "+14155559876",
                 *         "service": "iMessage",
                 *         "status": "active",
                 *         "joined_at": "2025-05-21T15:30:00.000Z",
                 *         "is_me": false
                 *       }
                 *     ]
                 */
                handles: components["schemas"]["ChatHandle"][];
                message: components["schemas"]["SentMessage"];
            };
        };
        UpdateChatRequest: {
            /**
             * @description New display name for the chat (group chats only)
             * @example Updated Team Name
             */
            display_name?: string;
            /**
             * Format: uri
             * @description URL of an image to set as the group chat icon (group chats only)
             * @example https://example.com/icon.png
             */
            group_chat_icon?: string;
        };
        AddParticipantRequest: {
            /**
             * @description Phone number (E.164 format) or email address of the participant to add
             * @example +12052532136
             */
            handle: string;
        };
        RemoveParticipantRequest: {
            /**
             * @description Phone number (E.164 format) or email address of the participant to remove
             * @example +12052532136
             */
            handle: string;
        };
        SendMessageToChatRequest: {
            message: components["schemas"]["MessageContent"];
        };
        GetMessagesResult: {
            /** @description List of messages */
            messages: components["schemas"]["Message"][];
            /**
             * @description Cursor for fetching the next page of results.
             *     Null if there are no more results to fetch.
             *     Pass this value as the `cursor` parameter in the next request.
             */
            next_cursor?: string | null;
        };
        /**
         * @description Valid webhook event types that can be subscribed to
         * @enum {string}
         */
        WebhookEventType: "message.sent" | "message.received" | "message.read" | "message.delivered" | "message.failed" | "reaction.added" | "reaction.removed" | "participant.added" | "participant.removed" | "chat.created" | "chat.group_name_updated" | "chat.group_icon_updated" | "chat.group_name_update_failed" | "chat.group_icon_update_failed" | "chat.typing_indicator.started" | "chat.typing_indicator.stopped";
        WebhookEventsResult: {
            /** @description List of all available webhook event types */
            events: components["schemas"]["WebhookEventType"][];
            /**
             * Format: uri
             * @description URL to the webhook events documentation
             * @constant
             */
            doc_url: "https://apidocs.linqapp.com/documentation/webhook-events";
        };
        WebhookSubscriptionResponse: {
            /**
             * @description Unique identifier for the webhook subscription
             * @example b2c3d4e5-f6a7-8901-bcde-f23456789012
             */
            id: string;
            /**
             * Format: uri
             * @description URL where webhook events will be sent
             * @example https://webhooks.example.com/linq/events
             */
            target_url: string;
            /**
             * @description List of event types this subscription receives
             * @example [
             *       "message.sent",
             *       "message.delivered",
             *       "message.read"
             *     ]
             */
            subscribed_events: components["schemas"]["WebhookEventType"][];
            /**
             * @description Whether this subscription is currently active
             * @example true
             */
            is_active: boolean;
            /**
             * Format: date-time
             * @description When the subscription was created
             * @example 2024-01-15T10:30:00Z
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the subscription was last updated
             * @example 2024-01-15T10:30:00Z
             */
            updated_at: string;
        };
        /** @description Response returned when creating a webhook subscription. Includes the signing secret which is only shown once. */
        WebhookSubscriptionCreatedResponse: {
            /**
             * @description Unique identifier for the webhook subscription
             * @example b2c3d4e5-f6a7-8901-bcde-f23456789012
             */
            id: string;
            /**
             * Format: uri
             * @description URL where webhook events will be sent
             * @example https://webhooks.example.com/linq/events
             */
            target_url: string;
            /**
             * @description Secret for verifying webhook signatures. Store this securely - it cannot be retrieved again.
             * @example whsec_abc123def456
             */
            signing_secret: string;
            /**
             * @description List of event types this subscription receives
             * @example [
             *       "message.sent",
             *       "message.delivered",
             *       "message.read"
             *     ]
             */
            subscribed_events: components["schemas"]["WebhookEventType"][];
            /**
             * @description Whether this subscription is currently active
             * @example true
             */
            is_active: boolean;
            /**
             * Format: date-time
             * @description When the subscription was created
             * @example 2024-01-15T10:30:00Z
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the subscription was last updated
             * @example 2024-01-15T10:30:00Z
             */
            updated_at: string;
        };
        CreateWebhookSubscriptionRequest: {
            /**
             * Format: uri
             * @description URL where webhook events will be sent. Must be HTTPS.
             * @example https://webhooks.example.com/linq/events
             */
            target_url: string;
            /**
             * @description List of event types to subscribe to
             * @example [
             *       "message.sent",
             *       "message.delivered"
             *     ]
             */
            subscribed_events: components["schemas"]["WebhookEventType"][];
        };
        UpdateWebhookSubscriptionRequest: {
            /**
             * Format: uri
             * @description New target URL for webhook events
             * @example https://webhooks.example.com/linq/events
             */
            target_url?: string;
            /**
             * @description Updated list of event types to subscribe to
             * @example [
             *       "message.sent",
             *       "message.delivered"
             *     ]
             */
            subscribed_events?: components["schemas"]["WebhookEventType"][];
            /**
             * @description Activate or deactivate the subscription
             * @example true
             */
            is_active?: boolean;
        };
        ListWebhookSubscriptionsResult: {
            /** @description List of webhook subscriptions */
            subscriptions: components["schemas"]["WebhookSubscriptionResponse"][];
        };
        ListPhoneNumbersResult: {
            /** @description List of phone numbers assigned to the partner */
            phone_numbers: components["schemas"]["PhoneNumberInfo"][];
        };
        PhoneNumberInfo: {
            /**
             * Format: uuid
             * @description Unique identifier for the phone number
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            id: string;
            /**
             * @description Phone number in E.164 format
             * @example +12025551234
             */
            phone_number: string;
            /**
             * @description Type of phone number
             * @example APPLE_ID
             * @enum {string}
             */
            type: "TWILIO" | "APPLE_ID";
            /**
             * @description ISO 3166-1 alpha-2 country code
             * @example US
             */
            country_code: string;
            capabilities: components["schemas"]["PhoneCapabilities"];
        };
        PhoneCapabilities: {
            /**
             * @description Whether SMS messaging is supported
             * @example true
             */
            sms: boolean;
            /**
             * @description Whether MMS messaging is supported
             * @example true
             */
            mms: boolean;
            /**
             * @description Whether voice calls are supported
             * @example false
             */
            voice: boolean;
        };
        /**
         * @description Linq API error codes for programmatic error handling.
         *
         *     ## Error Code Ranges
         *
         *     | Range | Category | Description |
         *     |-------|----------|-------------|
         *     | 1xxx | Client Errors | Validation failures, malformed requests |
         *     | 2xxx | Resource Errors | Not found, permission denied |
         *     | 3xxx | Infrastructure | Processing failures, retries exhausted |
         *     | 4xxx | Delivery | Message delivery failures |
         *     | 5xxx | Attachments | File upload/download failures |
         *
         *     ## Complete Error Code Reference
         *
         *     ### 1xxx: Client/Request Errors
         *
         *     | Code | Name | Description | HTTP |
         *     |------|------|-------------|------|
         *     | 1001 | `missing_required_field` | A required field is missing from the request | 400 |
         *     | 1002 | `invalid_phone_format` | Phone number must be in E.164 format (e.g., +14155551234) | 400 |
         *     | 1003 | `invalid_request_body` | Request body is malformed or contains invalid JSON | 400 |
         *     | 1004 | `invalid_message_content` | Message content or parts are invalid | 400 |
         *     | 1005 | `invalid_parameter` | A parameter value is invalid | 400 |
         *     | 1006 | `cannot_update_dm` | Cannot update a direct message chat (only group chats) | 400 |
         *     | 1007 | `rate_limit_exceeded` | Daily message limit exceeded for this partner | 429 |
         *
         *     ### 2xxx: Resource Errors
         *
         *     | Code | Name | Description | HTTP |
         *     |------|------|-------------|------|
         *     | 2001 | `chat_not_found` | The requested chat does not exist | 404 |
         *     | 2002 | `message_not_found` | The requested message does not exist | 404 |
         *     | 2003 | `attachment_not_found` | The requested attachment does not exist | 404 |
         *     | 2004 | `unauthorized` | Missing or invalid authentication token | 401 |
         *     | 2005 | `access_denied` | You don't have permission to access this resource | 403 |
         *     | 2006 | `phone_permission_denied` | You don't have permission to send from this phone number | 403 |
         *     | 2007 | `attachment_not_ready` | Attachment is still being processed | 404 |
         *     | 2008 | `recipient_not_allowed` | Recipient not in allowed list for this account | 403 |
         *
         *     ### 3xxx: Infrastructure Errors
         *
         *     | Code | Name | Description | HTTP |
         *     |------|------|-------------|------|
         *     | 3001 | `database_connection` | Database connection error (transient) | 500 |
         *     | 3002 | `database_query` | Database operation failed | 500 |
         *     | 3003 | `event_stream_connection` | Event stream connection error (transient) | 500 |
         *     | 3004 | `event_stream_publish` | Failed to publish to event stream | 500 |
         *     | 3005 | `network_timeout` | Network operation timed out | 504 |
         *     | 3006 | `internal_error` | Internal server error | 500 |
         *     | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | 500 |
         *
         *     ### 4xxx: Delivery Errors
         *
         *     | Code | Name | Description | HTTP |
         *     |------|------|-------------|------|
         *     | 4001 | `delivery_failed` | Request could not be delivered for processing | 500 |
         *     | 4002 | `phone_not_available` | Phone number is not available for this operation | 500 |
         *     | 4003 | `webhook_delivery_failed` | Webhook delivery to your endpoint failed | 500 |
         *     | 4004 | `service_unavailable` | External service is temporarily unavailable | 503 |
         *
         *     ### 5xxx: Attachment/File Errors
         *
         *     | Code | Name | Description | HTTP |
         *     |------|------|-------------|------|
         *     | 5001 | `file_upload_failed` | File upload failed | 500 |
         *     | 5002 | `file_download_failed` | File download failed | 500 |
         *     | 5003 | `presigned_url_failed` | Failed to generate file access URL | 500 |
         *     | 5004 | `invalid_file_type` | File type is not supported | 400 |
         *     | 5005 | `file_too_large` | File exceeds the maximum size limit | 400 |
         *     | 5006 | `content_type_mismatch` | File content type does not match URL extension | 400 |
         *
         *     ## Handling Errors
         *
         *     ```json
         *     {
         *       "success": false,
         *       "error": {
         *         "status": 400,
         *         "code": 1002,
         *         "message": "Phone number must be in E.164 format"
         *       },
         *       "trace_id": "abc123"
         *     }
         *     ```
         *
         *     **Recommended retry strategy for transient errors (3xxx, 4xxx with 5xx HTTP):**
         *     1. Wait 1-5 seconds, retry
         *     2. If still failing, wait 30 seconds
         *     3. After 3 failed attempts, log and alert
         * @example 1002
         * @enum {integer}
         */
        ErrorCode: 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 2001 | 2002 | 2003 | 2004 | 2005 | 2006 | 2007 | 2008 | 3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3007 | 4001 | 4002 | 4003 | 4004 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006;
        WebhookEnvelopeBase: {
            /**
             * @description API version for the webhook payload format
             * @example v3
             */
            api_version: string;
            /**
             * @description Date-based webhook payload version.
             *     Determined by the `?version=` query parameter in your webhook subscription URL.
             *     If no version parameter is specified, defaults based on subscription creation date.
             * @example 2025-01-01
             */
            webhook_version: string;
            event_type: components["schemas"]["WebhookEventType"];
            /**
             * Format: uuid
             * @description Unique identifier for this event (for deduplication)
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            event_id: string;
            /**
             * Format: date-time
             * @description When the event was created
             * @example 2025-11-23T17:30:00Z
             */
            created_at: string;
            /**
             * @description Trace ID for debugging and correlation across systems.
             * @example abc123def456
             */
            trace_id: string;
            /**
             * @description Partner identifier. Present on all webhooks for cross-referencing.
             * @example partner_abc123
             */
            partner_id: string;
        };
        /**
         * @description A text message part
         * @example {
         *       "type": "text",
         *       "value": "Hello!"
         *     }
         */
        "schemas-TextPartResponse": {
            /**
             * @description Indicates this is a text message part (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "text";
            /**
             * @description The text content
             * @example Check this out!
             */
            value: string;
        };
        /**
         * @description A media attachment part
         * @example {
         *       "type": "media",
         *       "id": "abc12345-1234-5678-9abc-def012345678",
         *       "url": "https://cdn.linqapp.com/attachments/abc12345/photo.jpg?signature=...",
         *       "filename": "photo.jpg",
         *       "mime_type": "image/jpeg",
         *       "size_bytes": 245678
         *     }
         */
        "schemas-MediaPartResponse": {
            /**
             * @description Indicates this is a media attachment part (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "media";
            /**
             * Format: uuid
             * @description Unique attachment identifier
             * @example abc12345-1234-5678-9abc-def012345678
             */
            id: string;
            /**
             * Format: uri
             * @description Presigned URL for downloading the attachment (expires in 1 hour).
             * @example https://cdn.linqapp.com/attachments/550e8400/photo.jpg?signature=...
             */
            url: string;
            /**
             * @description Original filename
             * @example photo.jpg
             */
            filename: string;
            /**
             * @description MIME type of the file
             * @example image/jpeg
             */
            mime_type: string;
            /**
             * @description File size in bytes
             * @example 245678
             */
            size_bytes: number;
        };
        /** @description iMessage effect applied to a message (screen or bubble animation) */
        "schemas-MessageEffect": {
            /**
             * @description Effect category
             * @example bubble
             * @enum {string}
             */
            type?: "screen" | "bubble";
            /**
             * @description Effect name (confetti, fireworks, slam, gentle, etc.)
             * @example gentle
             */
            name?: string;
        };
        /**
         * @description Unified payload for message webhooks when using `webhook_version: "2026-02-03"`.
         *
         *     This schema is used for message.sent, message.received, message.delivered, and message.read
         *     events when the subscription URL includes `?version=2026-02-03`.
         *
         *     Key differences from V1 (2025-01-01):
         *     - `direction`: "inbound" or "outbound" instead of `is_from_me` boolean
         *     - `sender_handle`: Full handle object for the sender
         *     - `chat`: Nested object with `id`, `is_group`, and `owner_handle`
         *     - Message fields (`id`, `parts`, `effect`, etc.) are at the top level, not nested in `message`
         *
         *     Timestamps indicate the message state:
         *     - `message.sent`: sent_at set, delivered_at=null, read_at=null
         *     - `message.received`: sent_at set, delivered_at=null, read_at=null
         *     - `message.delivered`: sent_at set, delivered_at set, read_at=null
         *     - `message.read`: sent_at set, delivered_at set, read_at set
         */
        MessageEventV2: {
            /** @description Chat information */
            chat: {
                /**
                 * Format: uuid
                 * @description Chat identifier
                 * @example 550e8400-e29b-41d4-a716-446655440000
                 */
                id: string;
                /**
                 * @description Whether this is a group chat
                 * @example true
                 */
                is_group?: boolean | null;
                /** @description Your phone number's handle. Always has is_me=true. */
                owner_handle?: components["schemas"]["ChatHandle"] | null;
            };
            /**
             * Format: uuid
             * @description Message identifier
             * @example 550e8400-e29b-41d4-a716-446655440001
             */
            id: string;
            /**
             * @description Idempotency key for deduplication of outbound messages.
             * @example unique-key
             */
            idempotency_key?: string | null;
            /**
             * @description Message direction - "outbound" if sent by you, "inbound" if received
             * @example outbound
             * @enum {string}
             */
            direction: "inbound" | "outbound";
            /** @description The handle that sent this message */
            sender_handle: components["schemas"]["ChatHandle"];
            /** @description Message parts (text and/or media) */
            parts: (components["schemas"]["schemas-TextPartResponse"] | components["schemas"]["schemas-MediaPartResponse"])[];
            /**
             * Format: date-time
             * @description When the message was sent. Null if not yet sent.
             * @example 2026-01-30T20:49:19.704Z
             */
            sent_at?: string | null;
            /**
             * Format: date-time
             * @description When the message was delivered. Null if not yet delivered.
             * @example 2026-01-30T20:49:20.352Z
             */
            delivered_at?: string | null;
            /**
             * Format: date-time
             * @description When the message was read. Null if not yet read.
             * @example null
             */
            read_at?: string | null;
            /** @description Reference to the message this is replying to (for threaded replies) */
            reply_to?: {
                /**
                 * Format: uuid
                 * @description ID of the message being replied to
                 */
                message_id?: string;
                /**
                 * Format: int32
                 * @description Index of the part being replied to
                 */
                part_index?: number;
            } | null;
            /** @description iMessage effect applied to the message (bubble or screen animation). Null if no effect. */
            effect?: components["schemas"]["schemas-MessageEffect"] | null;
            /**
             * @description The service used to send/receive the message
             * @example iMessage
             * @enum {string}
             */
            service: "iMessage" | "SMS" | "RCS";
            /**
             * @description The service that was requested when sending. Null for inbound messages.
             * @example iMessage
             * @enum {string|null}
             */
            preferred_service?: "iMessage" | "SMS" | "RCS" | "auto" | null;
        };
        /** @description Complete webhook payload for message.sent events (2026-02-03 format) */
        MessageSentWebhookV2: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["MessageEventV2"];
        };
        /** @description Complete webhook payload for message.received events (2026-02-03 format) */
        MessageReceivedWebhookV2: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["MessageEventV2"];
        };
        /** @description Complete webhook payload for message.read events (2026-02-03 format) */
        MessageReadWebhookV2: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["MessageEventV2"];
        };
        /** @description Complete webhook payload for message.delivered events (2026-02-03 format) */
        MessageDeliveredWebhookV2: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["MessageEventV2"];
        };
        /**
         * @description Error codes that appear in webhook failure events (`message.failed`,
         *     `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
         *
         *     | Code | Name | Description | Recommended Action |
         *     |------|------|-------------|-------------------|
         *     | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
         *     | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
         * @example 4001
         * @enum {integer}
         */
        WebhookErrorCode: 3007 | 4001;
        /**
         * @description Error details for message.failed webhook events.
         *     See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
         */
        MessageFailedEvent: {
            /**
             * @description Chat identifier (UUID)
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id?: string;
            /**
             * @description Message identifier (UUID)
             * @example 550e8400-e29b-41d4-a716-446655440001
             */
            message_id?: string;
            code: components["schemas"]["WebhookErrorCode"];
            /**
             * @description Human-readable description of the failure
             * @example Request expired before being processed
             */
            reason?: string;
            /**
             * Format: date-time
             * @description When the failure was detected
             * @example 2025-11-23T17:35:00Z
             */
            failed_at: string;
        };
        /** @description Complete webhook payload for message.failed events */
        MessageFailedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["MessageFailedEvent"];
        };
        ReactionEventBase: {
            /**
             * @description Chat identifier (UUID)
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id?: string;
            /**
             * @deprecated
             * @description DEPRECATED: Use from_handle instead. Phone number or email address of the person who added/removed the reaction.
             * @example +14155559876
             */
            from?: string;
            /**
             * @description The person who added/removed the reaction as a full handle object
             * @example {
             *       "id": "550e8400-e29b-41d4-a716-446655440011",
             *       "handle": "+14155559876",
             *       "is_me": false,
             *       "service": "iMessage",
             *       "status": "active",
             *       "joined_at": "2025-11-23T17:30:00.000Z",
             *       "left_at": null
             *     }
             */
            from_handle?: components["schemas"]["ChatHandle"];
            /**
             * @description Message identifier (UUID) that the reaction was added to or removed from
             * @example 550e8400-e29b-41d4-a716-446655440001
             */
            message_id?: string;
            /**
             * Format: int32
             * @description Index of the message part that was reacted to (0-based)
             * @example 0
             */
            part_index?: number;
            reaction_type: components["schemas"]["ReactionType"];
            /**
             * @description The actual emoji when reaction_type is "custom". Null for standard tapbacks.
             * @example null
             */
            custom_emoji?: string | null;
            /**
             * @description Whether this reaction was from the owner of the phone number (true) or from someone else (false)
             * @example false
             */
            is_from_me: boolean;
            /**
             * @description Message service type
             * @example iMessage
             * @enum {string}
             */
            service?: "iMessage" | "SMS" | "RCS";
            /**
             * Format: date-time
             * @description When the reaction was added or removed
             * @example 2025-11-23T17:35:00Z
             */
            reacted_at?: string;
        };
        /** @description Payload for reaction.added webhook events */
        ReactionAddedEvent: components["schemas"]["ReactionEventBase"];
        /** @description Complete webhook payload for reaction.added events */
        ReactionAddedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ReactionAddedEvent"];
        };
        /** @description Payload for reaction.removed webhook events */
        ReactionRemovedEvent: components["schemas"]["ReactionEventBase"];
        /** @description Complete webhook payload for reaction.removed events */
        ReactionRemovedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ReactionRemovedEvent"];
        };
        /** @description Payload for participant.added webhook events */
        ParticipantAddedEvent: {
            /**
             * @description Chat identifier (UUID) of the group chat
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id?: string;
            /**
             * @deprecated
             * @description DEPRECATED: Use participant instead. Handle (phone number or email address) of the added participant.
             * @example +14155559876
             */
            handle: string;
            /**
             * @description The added participant as a full handle object
             * @example {
             *       "id": "550e8400-e29b-41d4-a716-446655440011",
             *       "handle": "+14155559876",
             *       "is_me": false,
             *       "service": "iMessage",
             *       "status": "active",
             *       "joined_at": "2025-11-23T17:40:00.000Z",
             *       "left_at": null
             *     }
             */
            participant?: components["schemas"]["ChatHandle"];
            /**
             * Format: date-time
             * @description When the participant was added
             * @example 2025-11-23T17:40:00Z
             */
            added_at?: string;
        };
        /** @description Complete webhook payload for participant.added events */
        ParticipantAddedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ParticipantAddedEvent"];
        };
        /** @description Payload for participant.removed webhook events */
        ParticipantRemovedEvent: {
            /**
             * @description Chat identifier (UUID) of the group chat
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id?: string;
            /**
             * @deprecated
             * @description DEPRECATED: Use participant instead. Handle (phone number or email address) of the removed participant.
             * @example +14155559876
             */
            handle: string;
            /**
             * @description The removed participant as a full handle object
             * @example {
             *       "id": "550e8400-e29b-41d4-a716-446655440011",
             *       "handle": "+14155559876",
             *       "is_me": false,
             *       "service": "iMessage",
             *       "status": "removed",
             *       "joined_at": "2025-11-23T17:30:00.000Z",
             *       "left_at": "2025-11-23T17:45:00.000Z"
             *     }
             */
            participant?: components["schemas"]["ChatHandle"];
            /**
             * Format: date-time
             * @description When the participant was removed
             * @example 2025-11-23T17:45:00Z
             */
            removed_at?: string;
        };
        /** @description Complete webhook payload for participant.removed events */
        ParticipantRemovedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ParticipantRemovedEvent"];
        };
        /** @description Payload for chat.group_name_updated webhook events */
        ChatGroupNameUpdatedEvent: {
            /**
             * @description Chat identifier (UUID) of the group chat
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id: string;
            /**
             * @description Previous group name (null if no previous name)
             * @example Old Group Name
             */
            old_value?: string | null;
            /**
             * @description New group name (null if the name was removed)
             * @example New Group Name
             */
            new_value?: string | null;
            /**
             * @description The handle who made the change.
             * @example {
             *       "id": "550e8400-e29b-41d4-a716-446655440011",
             *       "handle": "+14155559876",
             *       "is_me": false,
             *       "service": "iMessage",
             *       "status": "active",
             *       "joined_at": "2025-11-23T17:30:00.000Z",
             *       "left_at": null
             *     }
             */
            changed_by_handle?: components["schemas"]["ChatHandle"] | null;
            /**
             * Format: date-time
             * @description When the update occurred
             * @example 2025-11-23T17:50:00Z
             */
            updated_at: string;
        };
        /** @description Complete webhook payload for chat.group_name_updated events */
        ChatGroupNameUpdatedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ChatGroupNameUpdatedEvent"];
        };
        /** @description Payload for chat.group_icon_updated webhook events */
        ChatGroupIconUpdatedEvent: {
            /**
             * @description Chat identifier (UUID) of the group chat
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id: string;
            /**
             * @description Previous icon URL (null if no previous icon)
             * @example https://example.com/old-icon.png
             */
            old_value?: string | null;
            /**
             * @description New icon URL (null if the icon was removed)
             * @example https://example.com/new-icon.png
             */
            new_value?: string | null;
            /**
             * @description The handle who made the change.
             * @example {
             *       "id": "550e8400-e29b-41d4-a716-446655440011",
             *       "handle": "+14155559876",
             *       "is_me": false,
             *       "service": "iMessage",
             *       "status": "active",
             *       "joined_at": "2025-11-23T17:30:00.000Z",
             *       "left_at": null
             *     }
             */
            changed_by_handle?: components["schemas"]["ChatHandle"] | null;
            /**
             * Format: date-time
             * @description When the update occurred
             * @example 2025-11-23T17:50:00Z
             */
            updated_at: string;
        };
        /** @description Complete webhook payload for chat.group_icon_updated events */
        ChatGroupIconUpdatedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ChatGroupIconUpdatedEvent"];
        };
        /**
         * @description Error details for chat.group_name_update_failed webhook events.
         *     See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
         */
        ChatGroupNameUpdateFailedEvent: {
            /**
             * @description Chat identifier (UUID) of the group chat
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id: string;
            error_code: components["schemas"]["WebhookErrorCode"];
            /**
             * Format: date-time
             * @description When the failure was detected
             * @example 2025-11-23T17:55:00Z
             */
            failed_at: string;
        };
        /** @description Complete webhook payload for chat.group_name_update_failed events */
        ChatGroupNameUpdateFailedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ChatGroupNameUpdateFailedEvent"];
        };
        /**
         * @description Error details for chat.group_icon_update_failed webhook events.
         *     See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
         */
        ChatGroupIconUpdateFailedEvent: {
            /**
             * @description Chat identifier (UUID) of the group chat
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id: string;
            error_code: components["schemas"]["WebhookErrorCode"];
            /**
             * Format: date-time
             * @description When the failure was detected
             * @example 2025-11-23T17:55:00Z
             */
            failed_at: string;
        };
        /** @description Complete webhook payload for chat.group_icon_update_failed events */
        ChatGroupIconUpdateFailedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ChatGroupIconUpdateFailedEvent"];
        };
        /** @description Payload for chat.created webhook events. Matches GET /v3/chats/{chatId} response. */
        ChatCreatedEvent: {
            /**
             * Format: uuid
             * @description Unique identifier for the chat
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            id: string;
            /**
             * @description Display name for the chat. Defaults to a comma-separated list of recipient handles. Can be updated for group chats.
             * @example +14155551234, +14155559876
             */
            display_name: string | null;
            /**
             * @description Service type for the chat
             * @example iMessage
             * @enum {string|null}
             */
            service?: "iMessage" | "SMS" | "RCS" | null;
            /**
             * @description List of chat participants with full handle details. Always contains at least two handles (your phone number and the other participant).
             * @example [
             *       {
             *         "id": "550e8400-e29b-41d4-a716-446655440010",
             *         "handle": "+14155551234",
             *         "is_me": true,
             *         "service": "iMessage",
             *         "status": "active",
             *         "joined_at": "2025-11-23T17:30:00.000Z",
             *         "left_at": null
             *       },
             *       {
             *         "id": "550e8400-e29b-41d4-a716-446655440011",
             *         "handle": "+14155559876",
             *         "is_me": false,
             *         "service": "iMessage",
             *         "status": "active",
             *         "joined_at": "2025-11-23T17:30:00.000Z",
             *         "left_at": null
             *       }
             *     ]
             */
            handles: components["schemas"]["ChatHandle"][];
            /**
             * @description Whether this is a group chat
             * @default false
             * @example true
             */
            is_group: boolean;
            /**
             * Format: date-time
             * @description When the chat was created
             * @example 2025-11-23T17:30:00Z
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the chat was last updated
             * @example 2025-11-23T17:30:00Z
             */
            updated_at: string;
        };
        /** @description Complete webhook payload for chat.created events */
        ChatCreatedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ChatCreatedEvent"];
        };
        /** @description Payload for chat.typing_indicator.started webhook events */
        ChatTypingIndicatorStartedEvent: {
            /**
             * Format: uuid
             * @description Chat identifier
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id: string;
        };
        /** @description Complete webhook payload for chat.typing_indicator.started events */
        ChatTypingIndicatorStartedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ChatTypingIndicatorStartedEvent"];
        };
        /** @description Payload for chat.typing_indicator.stopped webhook events */
        ChatTypingIndicatorStoppedEvent: {
            /**
             * Format: uuid
             * @description Chat identifier
             * @example 550e8400-e29b-41d4-a716-446655440000
             */
            chat_id: string;
        };
        /** @description Complete webhook payload for chat.typing_indicator.stopped events */
        ChatTypingIndicatorStoppedWebhook: components["schemas"]["WebhookEnvelopeBase"] & {
            data?: components["schemas"]["ChatTypingIndicatorStoppedEvent"];
        };
    };
    responses: {
        /** @description Invalid request - validation error */
        BadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "status": 400,
                 *         "code": 1002,
                 *         "message": "Phone number must be in E.164 format"
                 *       },
                 *       "success": false
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Unauthorized - missing or invalid authentication */
        Unauthorized: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "status": 401,
                 *         "code": 2004,
                 *         "message": "Unauthorized - missing or invalid authentication token"
                 *       },
                 *       "success": false
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Forbidden - no access to this resource */
        Forbidden: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "status": 403,
                 *         "code": 2005,
                 *         "message": "Access denied - insufficient permissions for this resource"
                 *       },
                 *       "success": false
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Resource not found */
        NotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "status": 404,
                 *         "code": 2001,
                 *         "message": "Resource not found"
                 *       },
                 *       "success": false
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Unprocessable Entity - request is valid but cannot be processed */
        UnprocessableEntity: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "status": 422,
                 *         "code": 1003,
                 *         "message": "Request is valid but cannot be processed"
                 *       },
                 *       "success": false
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Internal server error */
        InternalServerError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "status": 500,
                 *         "code": 3006,
                 *         "message": "Internal server error"
                 *       },
                 *       "success": false
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    listChats: {
        parameters: {
            query: {
                /**
                 * @description Phone number to filter chats by. Returns all chats made from this phone number.
                 *     Must be in E.164 format with the `+` sign URL-encoded as `%2B` (e.g., `%2B13343284472`).
                 */
                from: string;
                /** @description Maximum number of chats to return per page */
                limit?: number;
                /**
                 * @description Pagination cursor from the previous response's `next_cursor` field.
                 *     Omit this parameter for the first page of results.
                 */
                cursor?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of chats retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListChatsResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createChat: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateChatRequest"];
            };
        };
        responses: {
            /** @description Chat created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateChatResult"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getChat: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Chat found and returned successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Chat"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateChat: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateChatRequest"];
            };
        };
        responses: {
            /** @description Chat updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Chat"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    addParticipant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddParticipantRequest"];
            };
        };
        responses: {
            /** @description Participant addition queued successfully */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example accepted */
                        status?: string;
                        trace_id?: string;
                        /** @example Participant addition queued */
                        message?: string;
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    removeParticipant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RemoveParticipantRequest"];
            };
        };
        responses: {
            /** @description Participant removal queued successfully */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example accepted */
                        status?: string;
                        trace_id?: string;
                        /** @example Participant removal queued */
                        message?: string;
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    startTyping: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Typing indicator started successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    stopTyping: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Typing indicator stopped successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    markChatAsRead: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Chat marked as read successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    shareContactWithChat: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Contact shared successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getMessages: {
        parameters: {
            query?: {
                /** @description Pagination cursor from previous next_cursor response */
                cursor?: string;
                /** @description Maximum number of messages to return */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Messages retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetMessagesResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    sendMessageToChat: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SendMessageToChatRequest"];
            };
        };
        responses: {
            /** @description Message accepted for delivery */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SendMessageResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getMessageThread: {
        parameters: {
            query?: {
                /** @description Pagination cursor from previous next_cursor response */
                cursor?: string;
                /** @description Maximum number of messages to return */
                limit?: number;
                /** @description Sort order for messages (asc = oldest first, desc = newest first) */
                order?: "asc" | "desc";
            };
            header?: never;
            path: {
                /** @description ID of any message in the thread (can be originator or any reply) */
                messageId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Thread retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetThreadResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    sendVoiceMemoToChat: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "voice_memo_url": "https://example.com/voice-memo.m4a"
                 *     }
                 */
                "application/json": components["schemas"]["SendVoiceMemoToChatRequest"];
            };
        };
        responses: {
            /** @description Voice memo accepted for delivery */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SendVoiceMemoToChatResult"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            /** @description Voice memo file too large */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "error": {
                     *         "status": 413,
                     *         "code": 5001,
                     *         "message": "Voice memo file too large - maximum size is 10MB"
                     *       },
                     *       "success": false
                     *     }
                     */
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            422: components["responses"]["UnprocessableEntity"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the message to retrieve */
                messageId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Message found and returned successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Message"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the message to delete */
                messageId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DeleteMessageRequest"];
            };
        };
        responses: {
            /** @description Message deleted successfully (no content returned) */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    sendReaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the message to react to */
                messageId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SendReactionRequest"];
            };
        };
        responses: {
            /** @description Reaction added/removed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Reaction"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    requestUpload: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestUploadRequest"];
            };
        };
        responses: {
            /** @description Upload URL generated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestUploadResult"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the attachment */
                attachmentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Attachment found and returned successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "id": "550e8400-e29b-41d4-a716-446655440000",
                     *       "filename": "photo.jpg",
                     *       "content_type": "image/jpeg",
                     *       "size_bytes": 1024000,
                     *       "status": "complete",
                     *       "download_url": "https://cdn.example.com/attachments/550e8400-e29b-41d4-a716-446655440000/photo.jpg",
                     *       "created_at": "2024-01-15T10:30:00Z"
                     *     }
                     */
                    "application/json": components["schemas"]["Attachment"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listPhoneNumbers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Phone numbers retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "phone_numbers": [
                     *         {
                     *           "id": "550e8400-e29b-41d4-a716-446655440000",
                     *           "phone_number": "+12025551234",
                     *           "status": "ASSIGNED",
                     *           "type": "APPLE_ID",
                     *           "country_code": "US",
                     *           "capabilities": {
                     *             "sms": true,
                     *             "mms": true,
                     *             "voice": false
                     *           }
                     *         }
                     *       ]
                     *     }
                     */
                    "application/json": components["schemas"]["ListPhoneNumbersResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listWebhookEvents: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of available webhook event types */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "events": [
                     *         "message.sent",
                     *         "message.received",
                     *         "message.read",
                     *         "message.delivered",
                     *         "message.failed",
                     *         "reaction.added",
                     *         "reaction.removed",
                     *         "participant.added",
                     *         "participant.removed",
                     *         "chat.created",
                     *         "chat.group_name_updated",
                     *         "chat.group_icon_updated",
                     *         "chat.group_name_update_failed",
                     *         "chat.group_icon_update_failed",
                     *         "chat.typing_indicator.started",
                     *         "chat.typing_indicator.stopped"
                     *       ],
                     *       "doc_url": "https://apidocs.linqapp.com/documentation/webhook-events"
                     *     }
                     */
                    "application/json": components["schemas"]["WebhookEventsResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listWebhookSubscriptions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of webhook subscriptions retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListWebhookSubscriptionsResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createWebhookSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateWebhookSubscriptionRequest"];
            };
        };
        responses: {
            /** @description Webhook subscription created successfully. The signing_secret is only returned in this response - store it securely. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookSubscriptionCreatedResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getWebhookSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the webhook subscription */
                subscriptionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook subscription found and returned successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookSubscriptionResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateWebhookSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the webhook subscription */
                subscriptionId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateWebhookSubscriptionRequest"];
            };
        };
        responses: {
            /** @description Webhook subscription updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookSubscriptionResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteWebhookSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the webhook subscription */
                subscriptionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook subscription deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    webhookMessageSentV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "api_version": "v3",
                 *       "webhook_version": "2026-02-03",
                 *       "event_type": "message.sent",
                 *       "event_id": "e20feb41-7f67-43f0-89c8-a985cff3b568",
                 *       "created_at": "2026-02-05T19:52:18.101373886Z",
                 *       "trace_id": "2eff5df5c6f688733c007523c4d61cd9",
                 *       "partner_id": "your-partner-id",
                 *       "data": {
                 *         "chat": {
                 *           "id": "0c961e93-e7bf-4db2-bf7b-ea06826bcab4",
                 *           "is_group": false,
                 *           "owner_handle": {
                 *             "handle": "+12025551234",
                 *             "id": "8d79532a-f529-4244-a5cf-d443de051434",
                 *             "is_me": true,
                 *             "joined_at": "2026-01-21T21:59:45.191571Z",
                 *             "left_at": null,
                 *             "service": "iMessage",
                 *             "status": "active"
                 *           }
                 *         },
                 *         "id": "347d62c2-2170-4754-8d30-c76d0c727d96",
                 *         "idempotency_key": null,
                 *         "direction": "outbound",
                 *         "sender_handle": {
                 *           "handle": "+12025551234",
                 *           "id": "8d79532a-f529-4244-a5cf-d443de051434",
                 *           "is_me": true,
                 *           "joined_at": "2026-01-21T21:59:45.191571Z",
                 *           "left_at": null,
                 *           "service": "iMessage",
                 *           "status": "active"
                 *         },
                 *         "parts": [
                 *           {
                 *             "type": "text",
                 *             "value": "Hello from Linq!"
                 *           },
                 *           {
                 *             "filename": "photo.jpg",
                 *             "id": "f13dda7d-ecac-49eb-b3fe-16fe286abf19",
                 *             "mime_type": "image/jpeg",
                 *             "size_bytes": 245678,
                 *             "type": "media",
                 *             "url": "https://cdn.linqapp.com/attachments/a1b2c3d4/photo.jpg?signature=..."
                 *           }
                 *         ],
                 *         "effect": null,
                 *         "sent_at": "2026-02-05T19:52:17.219Z",
                 *         "delivered_at": null,
                 *         "read_at": null,
                 *         "service": "iMessage",
                 *         "preferred_service": null
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["MessageSentWebhookV2"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookMessageReceivedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "api_version": "v3",
                 *       "webhook_version": "2026-02-03",
                 *       "event_type": "message.received",
                 *       "event_id": "2915e81c-5068-4796-ace2-21d2c94ad298",
                 *       "created_at": "2026-02-05T19:31:13.736444093Z",
                 *       "trace_id": "8af9171a45022df2eb74ba4e4c83be0f",
                 *       "partner_id": "your-partner-id",
                 *       "data": {
                 *         "chat": {
                 *           "id": "8f392755-6865-4b18-880a-227f9d8b458f",
                 *           "is_group": false,
                 *           "owner_handle": {
                 *             "handle": "+12025551234",
                 *             "id": "6d6c617f-187a-4dcd-a0d5-988347a8c092",
                 *             "is_me": true,
                 *             "joined_at": "2026-01-04T05:48:51.321469Z",
                 *             "left_at": null,
                 *             "service": "iMessage",
                 *             "status": "active"
                 *           }
                 *         },
                 *         "id": "89e3566e-1d13-49e5-a8ee-48490d5bfeb7",
                 *         "direction": "inbound",
                 *         "sender_handle": {
                 *           "handle": "+12025559876",
                 *           "id": "e604375a-5913-483a-8278-c631e8f0ffda",
                 *           "is_me": false,
                 *           "joined_at": "2026-01-04T05:48:51.321469Z",
                 *           "left_at": null,
                 *           "service": "iMessage",
                 *           "status": "active"
                 *         },
                 *         "parts": [
                 *           {
                 *             "type": "text",
                 *             "value": "Hello!"
                 *           }
                 *         ],
                 *         "effect": null,
                 *         "reply_to": null,
                 *         "sent_at": "2026-02-05T19:31:13.074Z",
                 *         "delivered_at": null,
                 *         "read_at": null,
                 *         "service": "iMessage"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["MessageReceivedWebhookV2"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookMessageReadV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "api_version": "v3",
                 *       "webhook_version": "2026-02-03",
                 *       "event_type": "message.read",
                 *       "event_id": "8fd42065-b998-482a-93b3-da855f8dad17",
                 *       "created_at": "2026-02-05T19:13:58.833366566Z",
                 *       "trace_id": "cbb93c08fa1a3f3c4c2efc161d67f36d",
                 *       "partner_id": "your-partner-id",
                 *       "data": {
                 *         "chat": {
                 *           "id": "24e33345-e6cf-4f50-9d35-1d7fde8c9818",
                 *           "is_group": false,
                 *           "owner_handle": {
                 *             "handle": "+12025551234",
                 *             "id": "d31678e9-0442-48fd-b7ed-c898d245dd15",
                 *             "is_me": true,
                 *             "joined_at": "2026-01-18T03:38:41.442254Z",
                 *             "left_at": null,
                 *             "service": "iMessage",
                 *             "status": "active"
                 *           }
                 *         },
                 *         "id": "dc6d3f68-90df-48f0-a504-e65f239a383c",
                 *         "idempotency_key": null,
                 *         "direction": "outbound",
                 *         "sender_handle": {
                 *           "handle": "+12025551234",
                 *           "id": "d31678e9-0442-48fd-b7ed-c898d245dd15",
                 *           "is_me": true,
                 *           "joined_at": "2026-01-18T03:38:41.442254Z",
                 *           "left_at": null,
                 *           "service": "iMessage",
                 *           "status": "active"
                 *         },
                 *         "parts": [
                 *           {
                 *             "type": "text",
                 *             "value": "Hello world!"
                 *           }
                 *         ],
                 *         "effect": null,
                 *         "sent_at": "2026-02-05T19:13:57.814Z",
                 *         "delivered_at": "2026-02-05T19:13:57.948Z",
                 *         "read_at": "2026-02-05T19:13:58.177Z",
                 *         "service": "iMessage",
                 *         "preferred_service": null
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["MessageReadWebhookV2"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookMessageDeliveredV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "api_version": "v3",
                 *       "webhook_version": "2026-02-03",
                 *       "event_type": "message.delivered",
                 *       "event_id": "67c4ad39-e9b0-47f6-82f8-64bdd8ceafa6",
                 *       "created_at": "2026-02-05T19:52:22.593689073Z",
                 *       "trace_id": "abde7f6248fba00f97e8c7dc4782d7e0",
                 *       "partner_id": "your-partner-id",
                 *       "data": {
                 *         "chat": {
                 *           "id": "0c961e93-e7bf-4db2-bf7b-ea06826bcab4",
                 *           "is_group": false,
                 *           "owner_handle": {
                 *             "handle": "+12025551234",
                 *             "id": "8d79532a-f529-4244-a5cf-d443de051434",
                 *             "is_me": true,
                 *             "joined_at": "2026-01-21T21:59:45.191571Z",
                 *             "left_at": null,
                 *             "service": "iMessage",
                 *             "status": "active"
                 *           }
                 *         },
                 *         "id": "347d62c2-2170-4754-8d30-c76d0c727d96",
                 *         "idempotency_key": null,
                 *         "direction": "outbound",
                 *         "sender_handle": {
                 *           "handle": "+12025551234",
                 *           "id": "8d79532a-f529-4244-a5cf-d443de051434",
                 *           "is_me": true,
                 *           "joined_at": "2026-01-21T21:59:45.191571Z",
                 *           "left_at": null,
                 *           "service": "iMessage",
                 *           "status": "active"
                 *         },
                 *         "parts": [
                 *           {
                 *             "type": "text",
                 *             "value": "Hello world!"
                 *           },
                 *           {
                 *             "filename": "photo.gif",
                 *             "id": "b9ed828d-dbac-431f-889a-23f276384389",
                 *             "mime_type": "image/gif",
                 *             "size_bytes": 2776819,
                 *             "type": "media",
                 *             "url": "https://cdn.linqapp.com/attachments/b9ed828d/photo.gif?signature=..."
                 *           }
                 *         ],
                 *         "effect": null,
                 *         "sent_at": "2026-02-05T19:52:17.219Z",
                 *         "delivered_at": "2026-02-05T19:52:22.291Z",
                 *         "read_at": null,
                 *         "service": "iMessage",
                 *         "preferred_service": null
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["MessageDeliveredWebhookV2"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookMessageFailedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageFailedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookReactionAddedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReactionAddedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookReactionRemovedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReactionRemovedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookParticipantAddedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ParticipantAddedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookParticipantRemovedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ParticipantRemovedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookChatGroupNameUpdatedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatGroupNameUpdatedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookChatGroupIconUpdatedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatGroupIconUpdatedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookChatGroupNameUpdateFailedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatGroupNameUpdateFailedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookChatGroupIconUpdateFailedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatGroupIconUpdateFailedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookChatCreatedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatCreatedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookChatTypingIndicatorStartedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatTypingIndicatorStartedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webhookChatTypingIndicatorStoppedV2026: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatTypingIndicatorStoppedWebhook"];
            };
        };
        responses: {
            /** @description Webhook received successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
